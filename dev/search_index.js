var documenterSearchIndex = {"docs":
[{"location":"#PublicAPI.jl","page":"PublicAPI.jl","title":"PublicAPI.jl","text":"","category":"section"},{"location":"","page":"PublicAPI.jl","title":"PublicAPI.jl","text":"PublicAPI\nPublicAPI.@public\nPublicAPI.@strict\nPublicAPI.of","category":"page"},{"location":"#PublicAPI","page":"PublicAPI.jl","title":"PublicAPI","text":"PublicAPI\n\n(Image: Dev)\n\nNOTE: This is a proof-of-concept implementation of Feature request: Base.@public macro for declaring a public name without needing to export it · Issue #42117 · JuliaLang/julia.\n\nPublicAPI.jl provides a simple API for declaring API without exporting the names:\n\nusing PublicAPI: @public\n@public public_api_name\npublic_api_name() = 1\n\nexport exported_and_public_api_name\nexported_and_public_api_name() = 2\n\nThe public API can be queried using PublicAPI.of(module).  For example, the public API for PublicAPI.jl can be listed as:\n\njulia> using PublicAPI\n\njulia> apis = PublicAPI.of(PublicAPI);\n\njulia> sort!(fullname.(apis))\n3-element Vector{Tuple{Symbol, Symbol}}:\n (:PublicAPI, Symbol(\"@public\"))\n (:PublicAPI, Symbol(\"@strict\"))\n (:PublicAPI, :of)\n\nConsumers of the public API can opt-in a stricter semantics of using via PublicAPI.@strict\n\nimport PublicAPI\nPublicAPI.@strict using Upstream: api\n\nwhich ensures that Upstream.api is either exported or marked as @public.\n\n\n\n\n\n","category":"module"},{"location":"#PublicAPI.@public","page":"PublicAPI.jl","title":"PublicAPI.@public","text":"@public name₁ name₂ … nameₙ\n@public @macroname\n\nDeclare public API names for the current module.\n\nThe second form @public @macroname is equivalent to @public var\"@macroname\".\n\nExtended help\n\nNote that where this macro is invoked is important. Consider:\n\nmodule A1\n    using PublicAPI: @public\n    @public B, C\n    module B\n        f() = nothing\n    end\n    module C\n        using PublicAPI: @public\n        using ..B: f\n        @public f\n    end\nend\n\nand\n\nmodule A2\n    using PublicAPI: @public\n    @public B, C\n    module B\n        using PublicAPI: @public\n        f() = nothing\n        @public f\n    end\n    module C\n        using ..B: f\n    end\nend\n\nThe fully-qualified names A1.C.f and A2.B.f are public but A1.B.f and A2.C.f are private.\n\n\n\n\n\n","category":"macro"},{"location":"#PublicAPI.@strict","page":"PublicAPI.jl","title":"PublicAPI.@strict","text":"PublicAPI.@strict using Module: name₁, name₂, …, nameₙ\nPublicAPI.@strict import Module\n\nEnable strict import; i.e., fail on using non-public API.\n\nThe simple form import Module create a dummy object named Module that acts like the original Module but forbids access to the internal names.\n\nExtended help\n\nLimitation: Currently, PublicAPI.@strict with the simple form import Module creates a dummy local module and a global constant named Module is bind to it. Thus, unlike import Module, the expression PublicAPI.@strict import Module cannot be evaluated more than once inside a module.  This is an implementation detail that may be fixed in the future if we find a better implementation.\n\n\n\n\n\n","category":"macro"},{"location":"#PublicAPI.of","page":"PublicAPI.jl","title":"PublicAPI.of","text":"PublicAPI.of(provider::Module; [recursive = true]) -> apis::Vector\n\nList public API from the provider module.\n\nEach element api of apis supports the following accessor functions:\n\nModule(api) :: Module: module in which the API is defined\nnameof(api) :: Symbol: the name of the API in the module\nfullname(api) :: Tuple{Vararg{Symbol}}: the components of the fully-qualified name; i.e., (:Package, :SubModule, :function) for Package.SubModule.function.\n\nThe provider module itself is not included in the apis.\n\nKeyword Arguments\n\nrecursive::Bool = true: Include public APIs from public sub-modules.\n\n\n\n\n\n","category":"function"}]
}
